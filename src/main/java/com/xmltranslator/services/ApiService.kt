package com.xmltranslator.services

import com.google.gson.Gson
import com.intellij.openapi.components.Service
import com.xmltranslator.settings.XmlTranslatorSettings
import java.net.URI
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import java.time.Duration
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.CancellationException

/**
 * Service for handling Google Gemini API communication
 * 
 * @author Thanh Nguyen <thanhnguyen6702@gmail.com>
 */
@Service
class ApiService {
    
    private val gson = Gson()
    private var currentKeyIndex = AtomicInteger(0)
    private val httpClient = HttpClient.newBuilder()
        .connectTimeout(Duration.ofSeconds(60))
        .build()

    // Data classes for Google AI API
    data class GeminiRequest(
        val contents: List<Content>
    )
    
    data class Content(
        val parts: List<Part>
    )
    
    data class Part(
        val text: String
    )
    
    data class GeminiResponse(
        val candidates: List<Candidate>?
    )
    
    data class Candidate(
        val content: Content?
    )
    
    data class TranslationRequest(
        val source_language: String,
        val target_language: String,
        val strings: List<StringItem>
    )
    
    data class StringItem(
        val id: Int,
        val text: String,
        val name: String? = null
    )
    
    data class TranslationResponse(
        val translations: List<TranslatedItem>
    )
    
    data class TranslatedItem(
        val id: Int,
        val text: String
    )

    // Data class for model configuration
    data class ModelConfig(
        val model: String
    )

    private fun getApiKeys(): List<String> {
        val settings = XmlTranslatorSettings.getInstance()
        val keys = settings.getValidApiKeys()
        
        if (keys.isEmpty()) {
            throw Exception("Kh√¥ng c√≥ API key n√†o ƒë∆∞·ª£c c·∫•u h√¨nh. Vui l√≤ng th√™m API key trong Settings > Tools > XML Translator")
        }
        
        return keys
    }

    /**
     * Th·ª±c hi·ªán translation request v·ªõi specific API key (for parallel execution)
     */
    fun translateRequestWithApiKey(request: TranslationRequest, apiKey: String): TranslationResponse {
        // Check for cancellation before starting
        if (Thread.currentThread().isInterrupted) {
            throw CancellationException("API request ƒë√£ b·ªã h·ªßy tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu")
        }
        
        val keyMask = apiKey.substring(0, minOf(10, apiKey.length)) + "..."
        
        val startTime = System.currentTimeMillis()
        val prompt = buildPrompt(request)
        
        // Check for cancellation before API call
        if (Thread.currentThread().isInterrupted) {
            throw CancellationException("API request ƒë√£ b·ªã h·ªßy tr∆∞·ªõc khi call API")
        }
        
        try {
            val response = callGeminiAPI(apiKey, request, prompt)
            val result = parseGeminiResponse(response)
            
            val duration = System.currentTimeMillis() - startTime
            println("‚úÖ [${keyMask}] ${result.translations.size} strings ‚Üí ${duration}ms")
            
            return result
        } catch (e: Exception) {
            // Check for rate limit error (429)
            val isRateLimitError = e.message?.contains("status 429", ignoreCase = true) == true
            
            if (isRateLimitError) {
                println("‚ö†Ô∏è [${keyMask}] Rate limit exceeded (429). ƒê·ª£i 60 gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i...")
                Thread.sleep(60_000) // Wait 1 minute
                
                // Check for cancellation after waiting
                if (Thread.currentThread().isInterrupted) {
                    throw CancellationException("API request ƒë√£ b·ªã h·ªßy trong khi ƒë·ª£i rate limit")
                }
                
                println("üîÑ [${keyMask}] Th·ª≠ l·∫°i sau khi ƒë·ª£i rate limit...")
                val retryResponse = callGeminiAPI(apiKey, request, prompt)
                val result = parseGeminiResponse(retryResponse)
                
                val duration = System.currentTimeMillis() - startTime
                println("‚úÖ [${keyMask}] ${result.translations.size} strings ‚Üí ${duration}ms (sau retry)")
                
                return result
            } else {
                // Re-throw non-rate-limit errors
                throw e
            }
        }
    }
    
    /**
     * Get all available API keys for parallel execution
     */
    fun getAvailableApiKeys(): List<String> {
        return getApiKeys()
    }
    
    private fun getNextApiKey(): String {
        val keys = getApiKeys()
        val index = currentKeyIndex.getAndUpdate { (it + 1) % keys.size }
        return keys[index]
    }

    /**
     * Th·ª±c hi·ªán translation request v√† tr·∫£ v·ªÅ k·∫øt qu·∫£ ho·∫∑c throw exception n·∫øu l·ªói
     */
    fun translateRequest(request: TranslationRequest): TranslationResponse {
        val apiKey = getNextApiKey()
        println("DEBUG: G·ª≠i y√™u c·∫ßu translation t·ªõi Google AI API")
        println("DEBUG: S·ª≠ d·ª•ng API key: ${apiKey.substring(0, 10)}...")
        
        val prompt = buildPrompt(request)
        
        try {
            val response = callGeminiAPI(apiKey, request, prompt)
            return parseGeminiResponse(response)
        } catch (e: Exception) {
            // Check for rate limit error (429)
            val isRateLimitError = e.message?.contains("status 429", ignoreCase = true) == true
            val isTimeoutError = e.message?.contains("timeout", ignoreCase = true) == true
            
            println("üîÑ L·∫ßn th·ª≠ ƒë·∫ßu th·∫•t b·∫°i: ${e.message}")
            
            if (isRateLimitError) {
                println("‚ö†Ô∏è Rate limit exceeded (429). ƒê·ª£i 60 gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i...")
                Thread.sleep(60_000) // Wait 1 minute
                
                println("üîÑ Th·ª≠ l·∫°i sau khi ƒë·ª£i rate limit...")
                val retryResponse = callGeminiAPI(apiKey, request, prompt)
                return parseGeminiResponse(retryResponse)
            }
            
            val keys = getApiKeys()
            if (keys.size > 1 && !isTimeoutError && !isRateLimitError) {
                println("üîÑ Th·ª≠ l·∫°i v·ªõi API key kh√°c...")
                Thread.sleep(4000) // Wait before retry
                
                val retryApiKey = getNextApiKey()
                val retryResponse = callGeminiAPI(retryApiKey, request, prompt)
                return parseGeminiResponse(retryResponse)
            } else {
                if (isTimeoutError) {
                    throw Exception("‚è∞ Translation timeout: ${e.message}\n\nüí° G·ª£i √Ω: Th·ª≠ gi·∫£m batch size xu·ªëng d∆∞·ªõi ${request.strings.size}")
                } else if (isRateLimitError) {
                    throw Exception("üö´ Rate limit exceeded sau khi retry: ${e.message}")
                } else {
                    throw Exception("‚ùå Translation API th·∫•t b·∫°i: ${e.message}")
                }
            }
        }
    }
    
    /**
     * T√≠nh to√°n timeout d·ª±a tr√™n s·ªë l∆∞·ª£ng strings c·∫ßn d·ªãch
     */
    private fun calculateTimeout(stringCount: Int): Long {
        // Base timeout 30s + 5s per string, minimum 30s, maximum 300s (5 ph√∫t)
        val dynamicTimeout = 30 + (stringCount * 5)
        return maxOf(30, minOf(300, dynamicTimeout.toLong()))
    }
    
    /**
     * Public method ƒë·ªÉ check timeout settings cho m·ªôt batch size c·ª• th·ªÉ
     */
    fun getTimeoutInfo(stringCount: Int): String {
        val timeout = calculateTimeout(stringCount)
        return "‚è∞ Timeout cho $stringCount strings: ${timeout}s (${timeout/60.0} ph√∫t)"
    }
    
    /**
     * Get information about rate limit handling
     */
    fun getRateLimitInfo(): String {
        val apiKeyCount = getApiKeys().size
        return buildString {
            appendLine("üìä RATE LIMIT HANDLING:")
            appendLine("üîë API Keys: $apiKeyCount")
            appendLine("‚ö° Capacity: ${apiKeyCount * 10} calls/minute per key")
            appendLine("üîÑ Auto-retry: ƒê·ª£i 60 gi√¢y khi g·∫∑p 429 error")
            appendLine("üö´ Rate limit policies:")
            appendLine("   ‚Ä¢ 429 error ‚Üí Wait 60s ‚Üí Retry")
            appendLine("   ‚Ä¢ Multiple keys ‚Üí Switch to different key")
            appendLine("   ‚Ä¢ Timeout ‚Üí Suggest smaller batch size")
            append("üí° Tip: S·ª≠ d·ª•ng batch size 100 ƒë·ªÉ t·ªëi ∆∞u rate limit")
        }
    }
    
    private fun callGeminiAPI(apiKey: String, request: TranslationRequest, prompt: String): String {
        // Check for cancellation before starting API call
        if (Thread.currentThread().isInterrupted) {
            throw CancellationException("Gemini API call ƒë√£ b·ªã h·ªßy")
        }
        
        val modelName = getModelName()
        val url = "https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=$apiKey"
        val keyMask = apiKey.substring(0, minOf(10, apiKey.length)) + "..."
        
        val geminiRequest = GeminiRequest(
            contents = listOf(
                Content(
                    parts = listOf(Part(prompt))
                )
            )
        )
        
        val requestBody = gson.toJson(geminiRequest)
        
        // Dynamic timeout d·ª±a tr√™n request size
        val timeoutSeconds = calculateTimeout(request.strings.size)
        
        val httpRequest = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(requestBody))
            .timeout(Duration.ofSeconds(timeoutSeconds))
            .build()
        
        // Check for cancellation before sending request
        if (Thread.currentThread().isInterrupted) {
            throw CancellationException("HTTP request ƒë√£ b·ªã h·ªßy tr∆∞·ªõc khi g·ª≠i")
        }
        
        val response = try {
            httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString())
        } catch (e: java.net.http.HttpTimeoutException) {
            println("‚è∞ [${keyMask}] TIMEOUT sau ${timeoutSeconds}s")
            throw Exception("‚è∞ Request timeout sau ${timeoutSeconds}s. Th·ª≠ gi·∫£m s·ªë l∆∞·ª£ng strings ho·∫∑c ki·ªÉm tra k·∫øt n·ªëi m·∫°ng. Chi ti·∫øt: ${e.message}")
        } catch (e: java.net.ConnectException) {
            println("üîå [${keyMask}] CONNECTION ERROR")
            throw Exception("üîå Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi Google API. Ki·ªÉm tra k·∫øt n·ªëi internet. Chi ti·∫øt: ${e.message}")
        } catch (e: java.io.IOException) {
            println("üåê [${keyMask}] IO ERROR: ${e.message}")
            throw Exception("üåê L·ªói m·∫°ng khi g·ªçi API. Chi ti·∫øt: ${e.message}")
        }
        
        // Check for cancellation after receiving response
        if (Thread.currentThread().isInterrupted) {
            throw CancellationException("Response processing ƒë√£ b·ªã h·ªßy")
        }
        
        if (response.statusCode() != 200) {
            val errorBody = response.body().take(500) // Limit error message length
            println("üö´ [${keyMask}] HTTP ${response.statusCode()}: $errorBody")
            throw Exception("üö´ API request th·∫•t b·∫°i v·ªõi status ${response.statusCode()}: $errorBody")
        }
        
        val geminiResponse = gson.fromJson(response.body(), GeminiResponse::class.java)
        val generatedText = geminiResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text
            ?: throw Exception("Kh√¥ng c√≥ n·ªôi dung trong API response")
        
        return generatedText
    }
    
    private fun buildPrompt(request: TranslationRequest): String {
        // S·ª≠ d·ª•ng examples nh∆∞ b·∫£n Python - complete set
        val examples = """
input: {
  "source_language": "en",
  "target_language": "ko",
  "strings": [
    {"id": 1, "text": "Your document has been saved successfully."},
    {"id": 2, "text": "Please check your internet connection and try again."},
    {"id": 3, "text": "This feature is not available in the free version."}
  ]
}
output: {
  "translations": [
    {"id": 1, "text": "Î¨∏ÏÑúÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§."},
    {"id": 2, "text": "Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî."},
    {"id": 3, "text": "Ïù¥ Í∏∞Îä•ÏùÄ Î¨¥Î£å Î≤ÑÏ†ÑÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§."}
  ]
}

input: {
  "source_language": "en",
  "target_language": "fr",
  "strings": [
    {"id": 1, "text": "QR & Barcode Scanner"}
  ]
}
output: {
  "translations": [
    {"id": 1, "text": "Scanner de QR & code-barres"}
  ]
}

input: {
  "source_language": "en",
  "target_language": "ko",
  "strings": [
    {"id": 1, "text": "Don't forget to write tag #XpertScan"},
    {"id": 2, "text": "Can't find an app that supports this action"}
  ]
}
output: {
  "translations": [
    {"id": 1, "text": "#XpertScan ÌÉúÍ∑∏Î•º ÏûëÏÑ±ÌïòÎäî Í≤ÉÏùÑ ÏûäÏßÄ ÎßàÏÑ∏Ïöî"},
    {"id": 2, "text": "Ïù¥ ÏûëÏóÖÏùÑ ÏßÄÏõêÌïòÎäî Ïï±ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§"}
  ]
}

input: {
  "source_language": "en",
  "target_language": "zh",
  "strings": [
    {"id": 1, "text": "Export as PDF failed"},
    {"id": 2, "text": "Share as PDF failed"},
    {"id": 3, "text": "Export to gallery failed"},
    {"id": 4, "text": "Share as picture failed"},
    {"id": 5, "text": "Print PDF failed"},
    {"id": 6, "text": "Insert password"}
  ]
}
output: {
  "translations": [
    {"id": 1, "text": "ÂØºÂá∫‰∏∫PDFÂ§±Ë¥•"},
    {"id": 2, "text": "ÂàÜ‰∫´‰∏∫PDFÂ§±Ë¥•"},
    {"id": 3, "text": "ÂØºÂá∫Âà∞ÂõæÂ∫ìÂ§±Ë¥•"},
    {"id": 4, "text": "ÂàÜ‰∫´‰∏∫ÂõæÁâáÂ§±Ë¥•"},
    {"id": 5, "text": "ÊâìÂç∞PDFÂ§±Ë¥•"},
    {"id": 6, "text": "ËØ∑ËæìÂÖ•ÂØÜÁ†Å"}
  ]
}

input: {
  "source_language": "en",
  "target_language": "vi",
  "strings": [
    {"id": 1, "text": "Export as PDF failed"},
    {"id": 2, "text": "Share as PDF failed"},
    {"id": 3, "text": "Export to gallery failed"},
    {"id": 4, "text": "Share as picture failed"},
    {"id": 5, "text": "Print PDF failed"},
    {"id": 6, "text": "Insert password"}
  ]
}
output: {
  "translations": [
    {"id": 1, "text": "Xu·∫•t PDF th·∫•t b·∫°i"},
    {"id": 2, "text": "Chia s·∫ª d∆∞·ªõi d·∫°ng PDF th·∫•t b·∫°i"},
    {"id": 3, "text": "Xu·∫•t v√†o th∆∞ vi·ªán th·∫•t b·∫°i"},
    {"id": 4, "text": "Chia s·∫ª d∆∞·ªõi d·∫°ng h√¨nh ·∫£nh th·∫•t b·∫°i"},
    {"id": 5, "text": "In PDF th·∫•t b·∫°i"},
    {"id": 6, "text": "Nh·∫≠p m·∫≠t kh·∫©u"}
  ]
}

input: {
  "source_language": "en",
  "target_language": "it",
  "strings": [
    {"id": 1, "text": "Export as PDF failed"},
    {"id": 2, "text": "Share as PDF failed"},
    {"id": 3, "text": "Export to gallery failed"},
    {"id": 4, "text": "Share as picture failed"},
    {"id": 5, "text": "Print PDF failed"},
    {"id": 6, "text": "Insert password"}
  ]
}
output: {
  "translations": [
    {"id": 1, "text": "Esportazione come PDF fallita"},
    {"id": 2, "text": "Condivisione come PDF fallita"},
    {"id": 3, "text": "Esportazione nella galleria fallita"},
    {"id": 4, "text": "Condivisione come immagine fallita"},
    {"id": 5, "text": "Stampa PDF fallita"},
    {"id": 6, "text": "Inserisci la password"}
  ]
}

input: {
  "source_language": "en",
  "target_language": "vi",
  "strings": [
    {"id": 1, "text": "Enable <b>Notifications</b> for continuous using when the app is closed."}
  ]
}
output: {
  "translations": [
    {"id": 1, "text": "B·∫≠t <b>Th√¥ng b√°o</b> c·ªßa ·ª©ng d·ª•ng ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng khi ·ª©ng d·ª•ng b·ªã ƒë√≥ng."}
  ]
}

input: {
  "source_language": "en",
  "target_language": "vi",
  "strings": [
    {"id": 1, "text": "Dear User,\\n\\nThank you for using our service.\\r\\nPlease note the following:\\n\\t- Your subscription expires soon.\\n\\t- Renew to continue enjoying premium features.\\n\\nBest regards,\\nThe Support Team"},
    {"id": 2, "text": "Error!\\r\\n\\tSomething went wrong while processing your request.\\nPlease try again later or contact support."}
  ]
}
output: {
  "translations": [
    {"id": 1, "text": "K√≠nh g·ª≠i ng∆∞·ªùi d√πng,\\n\\nC·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng d·ªãch v·ª• c·ªßa ch√∫ng t√¥i.\\r\\nVui l√≤ng l∆∞u √Ω:\\n\\t- G√≥i ƒëƒÉng k√Ω c·ªßa b·∫°n s·∫Øp h·∫øt h·∫°n.\\n\\t- Gia h·∫°n ƒë·ªÉ ti·∫øp t·ª•c t·∫≠n h∆∞·ªüng c√°c t√≠nh nƒÉng cao c·∫•p.\\n\\nTr√¢n tr·ªçng,\\nƒê·ªôi ng≈© H·ªó tr·ª£"},
    {"id": 2, "text": "L·ªói!\\r\\n\\tƒê√£ x·∫£y ra s·ª± c·ªë khi x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n.\\nVui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá b·ªô ph·∫≠n h·ªó tr·ª£."}
  ]
}

input: {
  "source_language": "en",
  "target_language": "vi",
  "strings": [
    {"id": 1, "text": "Set app <font color=\"#FF3E3E\"><b>PDF Reader</b></font> as the default PDF reader"},
    {"id": 2, "text": "Click <font color=\"#007AFF\"><b>Allow</b></font> to enable permissions"}
  ]
}
output: {
  "translations": [
    {"id": 1, "text": "ƒê·∫∑t ·ª©ng d·ª•ng <font color=\"#FF3E3E\"><b>PDF Reader</b></font> l√†m tr√¨nh ƒë·ªçc PDF m·∫∑c ƒë·ªãnh"},
    {"id": 2, "text": "Nh·∫•n <font color=\"#007AFF\"><b>Cho ph√©p</b></font> ƒë·ªÉ b·∫≠t quy·ªÅn"}
  ]
}

input: {
  "source_language": "en",
  "target_language": "ko",
  "strings": [
    {"id": 1, "text": "Download <font color=\"#34C759\"><b>Premium</b></font> version for unlimited features"},
    {"id": 2, "text": "Status: <font color=\"#FF9500\"><b>Processing...</b></font>"}
  ]
}
output: {
  "translations": [
    {"id": 1, "text": "<font color=\"#34C759\"><b>ÌîÑÎ¶¨ÎØ∏ÏóÑ</b></font> Î≤ÑÏ†ÑÏùÑ Îã§Ïö¥Î°úÎìúÌïòÏó¨ Î¨¥Ï†úÌïú Í∏∞Îä•ÏùÑ Ïù¥Ïö©ÌïòÏÑ∏Ïöî"},
    {"id": 2, "text": "ÏÉÅÌÉú: <font color=\"#FF9500\"><b>Ï≤òÎ¶¨ Ï§ë...</b></font>"}
  ]
}
        """.trimIndent()
        
        val requestJson = gson.toJson(request)
        
        return """
$examples


input: $requestJson
output:"""
    }
    
    private fun parseGeminiResponse(responseText: String): TranslationResponse {
        try {
            // Clean response text - gi·ªëng nh∆∞ Python version
            val cleanContent = responseText
                .replace("```json\n", "")
                .replace("\n```", "")
                .replace("```json", "")
                .replace("```", "")
                .trim()
            
            val response = gson.fromJson(cleanContent, TranslationResponse::class.java)
            
            // Validate response structure
            if (response.translations.isEmpty()) {
                throw Exception("Response kh√¥ng c√≥ translations")
            }
            
            // Validate t·∫•t c·∫£ translations c√≥ ID
            val missingIds = response.translations.filter { it.id <= 0 }
            if (missingIds.isNotEmpty()) {
                throw Exception("C√≥ ${missingIds.size} translations thi·∫øu ID h·ª£p l·ªá")
            }
            
            // Validate kh√¥ng c√≥ duplicate IDs
            val duplicateIds = response.translations.groupBy { it.id }.filter { it.value.size > 1 }
            if (duplicateIds.isNotEmpty()) {
                throw Exception("C√≥ duplicate IDs: ${duplicateIds.keys.joinToString(", ")}")
            }
            
            // Sort translations theo ID ƒë·ªÉ ƒë·∫£m b·∫£o th·ª© t·ª± ch√≠nh x√°c
            val sortedTranslations = response.translations.sortedBy { it.id }
            
            return TranslationResponse(sortedTranslations)
            
        } catch (e: Exception) {
            println("L·ªñI: Kh√¥ng th·ªÉ parse response: ${e.message}")
            throw Exception("Kh√¥ng th·ªÉ parse translation response: ${e.message}")
        }
    }

    /**
     * Fetch model name from remote URL (no caching)
     */
    private fun getModelName(): String {
        try {
            val modelUrl = "https://gist.githubusercontent.com/Thanh-apero/9a3fe43982e4d75cec32dc297f5317a2/raw/model.json"
            
            val httpRequest = HttpRequest.newBuilder()
                .uri(URI.create(modelUrl))
                .header("Accept", "application/json")
                .GET()
                .timeout(Duration.ofSeconds(10))
                .build()
            
            val response = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString())
            
            if (response.statusCode() == 200) {
                val modelConfig = gson.fromJson(response.body(), ModelConfig::class.java)
                println("üì° Model fetched: ${modelConfig.model}")
                return modelConfig.model
            } else {
                throw Exception("Failed to fetch model config: HTTP ${response.statusCode()}")
            }
            
        } catch (e: Exception) {
            println("‚ö†Ô∏è Failed to fetch model config: ${e.message}")
            
            // Fallback to default model
            val defaultModel = "gemini-2.0-flash-lite"
            println("üîÑ Using default model: $defaultModel")
            return defaultModel
        }
    }
    
    /**
     * Get current model info for debugging
     */
    fun getModelInfo(): String {
        val currentModel = try {
            getModelName()
        } catch (e: Exception) {
            "Error: ${e.message}"
        }
        
        return buildString {
            appendLine("ü§ñ CURRENT MODEL INFO:")
            appendLine("üì¶ Model: $currentModel")
            appendLine("üíæ Cache: Disabled (fetch m·ªói l·∫ßn translate)")
            appendLine("üîó Source: https://gist.githubusercontent.com/Thanh-apero/9a3fe43982e4d75cec32dc297f5317a2/raw/model.json")
            append("üîÑ Strategy: Fetch on every translation")
        }
    }
} 